@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix : <http://example.org/ns#>.

######
# Reasoning rules
######

# RelatedDataAppInput
(_:usage _:data _:app _:input _:ai _:u) log:onNegativeSurface {
	_:usage a :UsageContext;
		:app _:ai.
	_:ai :policy _:app.
	_:app a :AppPolicy;
		:input_spec _:input.
	_:data a :Data;
		:uri _:u.
	_:input :data _:u.

	() log:onNegativeSurface {
		_:m a :RelatedDataAppInput;
			:usage _:usage;
			:data _:data;
			:app _:app;
			:input _:input.
	}.
}.

# InputPolicyForOutput
(_:q _:data _:input _:app _:output_spec _:inputPort _:policy) log:onNegativeSurface {
	_:q a :RelatedDataAppInput;
		:data _:data;
		:input _:input;
		:app _:app.

	_:app :output_spec _:output_spec.
	_:output_spec :from _:inputPort.
	_:input :port _:inputPort.
	_:data :policy _:policy.

	() log:onNegativeSurface {
		_:m a :InputPolicyForOutput;
			:input _:input;
			:policy _:policy;
			:output_spec _:output_spec.
	}.
}.

# DeletedAttribute (now ForwardLink)
(_:attr _:N _:AT _:V _:input _:inputPort _:output_spec _:re _:filter) log:onNegativeSurface {
	_:attr a :Attribute;
		:name _:N;
		:class _:AT;
		:value _:V.
	_:input a :InputSpec;
		:port _:inputPort.

		_:output_spec a :OutputSpec;
			:from _:inputPort;
			:refinement _:re.
		_:re a :Delete;
			:filter _:filter.
		_:filter a :Filter.
		# TODO: Fix filter for "any" filtering target value; example works because all attributes are deleted. Maybe using subclass, because we are using N3 and that's easy to support?
		_:filter a :Filter;
			# :input _:inputPort;
			:name _:N;
			:class _:AT;
			:value _:V.

	() log:onNegativeSurface {
		_:mm a :ForwardLink;
			:output_spec _:output_spec;
			:ref :nil.
		_:attr
			:output_to _:mm.
	}.
}.

# UnsatisfiedRequirement
(_:x _:data _:input _:policy _:requirement _:T _:N) log:onNegativeSurface {
	_:x a :RelatedDataAppInput;
		:data _:data;
		:input _:input.

	_:data :policy _:policy.
	_:policy :requirement _:requirement.
	_:requirement
		:real_type _:T;
		:name _:N.

    # # Won't work, because RDF Surfaces hold open world asumption, and negation/negative surface is also in this sense... Patrick suggested using N3's scoped negation instead, as shown below.
	# (_:provide) log:onNegativeSurface {
	# 	_:input :provide _:provide.
	# 	_:provide
	# 		:type _:T;
	# 		:name _:N.
	# }.
    (_:provide _:scope) log:onPositiveSurface {
        ( () { _:input :provide _:provide. _:provide :type _:T; :name _:N} ()) log:collectAllIn _:scope.
    }.

	() log:onNegativeSurface {
		_:m a :UnsatisfiedRequirement;
            :input _:input;
            :data _:data;
			:type _:T;
			:name _:N.

	}.
}.

# UnmatchedExpectation
(_:x _:input _:data _:expect _:T _:N) log:onNegativeSurface {
    _:x a :RelatedDataAppInput;
        :input _:input;
        :data _:data.
    _:input :expect _:expect.
    _:expect
        :type _:T;
        :name _:N.
    (_:policy _:tag _:scope) log:onPositiveSurface {
        ( () {
            _:data :policy _:policy.
            _:policy :tag _:tag.
            _:tag
                :type _:T;
                :name _:N.
            } ()) log:collectAllIn _:scope.
    }.

    () log:onNegativeSurface {
        _:m a :UnmatchedExpectation;
            :input _:input;
            :data _:data;
            :type _:T;
            :name _:N.
    }.
}.

# ProhibitedUse
# TODO: needs verification
(_:x _:data _:app _:input _:ds _:N _:P _:policy _:prohibition _:ac _:ds) log:onNegativeSurface {
	_:x a :RelatedDataAppInput;
		:data _:data;
		:app _:app;
		:input _:input.
	
	_:data :policy _:policy.
	_:policy :prohibition _:prohibition.
	_:prohibition
		:mode :Use;
		:activation_condition _:ac.
	_:ac
		:app _:N;
		:purpose _:P.

	() log:onNegativeSurface {
		() log:onNegativeSurface {
			_:app :name _:N.
			_:input :purpose _:P.
		}.
		() log:onNegativeSurface {
			_:input :downsteram _:ds.
			_:ds
				:app_name _:N;
				:purpose _:P.
		}.
	}.

	() log:onNegativeSurface {
		_:m a :ProhibitedUse;
			:mode :Use;
			:app _:N;
			:purpose _:P.
	}.
}.

:UnsatisfiedRequirement rdfs:subClassOf :Conflict.
:UnmatchedExpectation rdfs:subClassOf :Conflict.
:ProhibitedUse rdfs:subClassOf :Conflict.

### Conflict
## Not used. Use subclass instead. Kept here for historical reference.
## Will create duplicates. Not useful. See below.
# (_:T _:N _:ur _:ue _:pu _:M _:App) log:onNegativeSurface {
# 	() log:onNegativeSurface {
# 		() log:onNegativeSurface {
# 			_:ur a :UnsatisfiedRequirement;
# 				:type _:T;
# 				:name _:N.
# 		}.

# 		() log:onNegativeSurface {
# 			_:ue a :UnmatchedExpectation;
# 				:type _:T;
# 				:name _:N.
# 		}.

# 		() log:onNegativeSurface {
# 			_:pu a :ProhibitedUse;
# 				:mode _:M;
# 				:app _:App;
# 				:purpose _:P.
# 		}.
# 	}.

# 	() log:onNegativeSurface {
# 		_:m a :Conflict;
# 			:unsatisfiedRequirement _:ur;
# 			:unmatchedExpectation _:ue;
# 			:prohibitedUse _:pu.

# 	}.
# }.

## Won't reuse the same _:m.
# (_:m) log:onPositiveSurface {
# 	(_:ur _:T _:N) log:onNegativeSurface {
# 		_:ur a :UnsatisfiedRequirement;
# 			:type _:T;
# 			:name _:N.

# 		() log:onNegativeSurface {
# 			_:m a :Conflict;
# 				:unsatisfiedRequirement _:ur.

# 		}.
# 	}.
# 	(_:ue _:T _:N) log:onNegativeSurface {
# 		_:ue a :UnmatchedExpectation;
# 			:type _:T;
# 			:name _:N.

# 		() log:onNegativeSurface {
# 			_:m a :Conflict;
# 				:unmatchedExpectation _:ue.
# 		}
# 	}
# }.

# ActivatedObligation
(_:x _:usage _:data _:app _:input _:policy _:obligation _:ob _:args _:ac _:P) log:onNegativeSurface {
	_:x a :RelatedDataAppInput;
		:usage _:usage;
		:data _:data;
		:app _:app;
		:input _:input.
	_:data :policy _:policy.
	_:policy :obligation _:obligation.
	_:obligation
		:obligation_class _:ob;
		:argument _:args;
		:activation_condition _:ac.

	# TODO: Support more general checks, particularly the "any".
	# Currently it's correct without the "any" part.
	_:ac
		# :user _:U;
		# :app _:N;
		:purpose _:P.	
	
	# _:usage :user _:U.
	# _:app :name _:N.
	_:input :purpose _:P.

	() log:onNegativeSurface {
		_:m a :ActivatedObligation;
			:purpose _:P;
			:class _:ob;
			:args _:args.
	}.
}.

# OutputAttribute
(_:x _:input _:policy _:output_spec _:P _:attr _:N _:T _:V _:T1 _:V1) log:onNegativeSurface {

	_:x a :InputPolicyForOutput;
		:input _:input;
		:policy _:policy;
		:output_spec _:output_spec.
	_:output_spec :port _:P.

	() log:onNegativeSurface {
		() log:onNegativeSurface {
			_:policy :attribute _:attr.
			_:attr
				:name _:N;
				:class _:T;
				:value _:V.

			(_:y _:context) log:onPositiveSurface {
				(
					()
					{
						_:attr :output_to _:y.
						_:y :output_spec _:output_spec;
							:ref :nil.
					}
					()
				) log:collectAllIn (_:context 1).
			}.

		}.
		() log:onNegativeSurface {  # This branch is not checked by me
			_:policy :attribute _:attr.
			_:attr
				:name _:N;
				:class _:T1;
				:value _:V1.

			_:input :port _:inputPort.
			
			_:output_spec :refinement _:refinement.
			_:refinement :filter _:filter.
			_:filter a :Edit;
				:input _:inputPort;
				:name _:N;
				:class _:T1;
				:value _:V1;
				:new_class _:T;
				:new_value _:V.
		}.
	}.

	() log:onNegativeSurface {
		_:m a :OutputAttribute, :Attribute;
			:name _:N;
			:class _:T;
			:value _:V;
			:port _:P.

		_:mm a :ForwardLink;
			:output_spec _:output_spec;
			:ref _:m.

		_:attr
			:output_to _:mm;
			:debug _:m.
	}.
}.

## Real Type (of Tagging) -- the type without any subtype. This is a helper for OutputTagging.
(_:x _:T) log:onNegativeSurface {
	_:x a :Tagging;
		:type _:T.

	(_:t2 _:scope) log:onPositiveSurface {
		(
			()
			{
				_:x :type _:t2.
				_:t2 rdfs:subClassOf _:T.
			}
			()
		) log:collectAllIn _:scope.
	}.

	() log:onNegativeSurface {
		_:x :real_type _:T.
	}.
}.

# OutputTagging
(_:x _:input _:policy _:output_spec _:P _:tagging _:T _:ar _:link0 _:ar1 _:vbs) log:onNegativeSurface {
	_:x a :InputPolicyForOutput;
		:input _:input;
		:policy _:policy;
		:output_spec _:output_spec.
	_:output_spec :port _:P.
	_:policy :tagging _:tagging.
	_:tagging
		# :type _:T;
		:real_type _:T;
		:attribute_ref _:ar.

	_:ar :output_to _:link0.
	_:link0 :output_spec _:output_spec;
		:ref _:ar1.

	_:ar1 log:notEqualTo :nil.

	(_:v _:link _:v1 _:context) log:onPositiveSurface {
		(
			_:v1
			{
				_:tagging :validity_binding _:v.
				_:v :output_to _:link.
				_:link :output_spec _:output_spec;
					:ref _:v1.
			}
			_:vbs
		) log:collectAllIn (_:context 2).
		(
			()
			{
				:nil list:in _:vbs.
			}
			()
		) log:collectAllIn (_:context 2).
	}.

	() log:onNegativeSurface {
		_:m a :OutputTagging, :Tagging;
			:type _:T;
			:attribute_ref _:ar1;
			:validity_binding_list _:vbs;
			:port _:P;
			:from _:tagging.
	}.
}.

(_:m _:vbs _:vb) log:onNegativeSurface {
	_:m a :OutputTagging;
		:validity_binding_list _:vbs.

	_:vb list:in _:vbs.

	() log:onNegativeSurface {
		_:m :validity_binding _:vb.
	}.
}.

#OutputObligation
(_:x _:input _:policy _:output_spec _:P _:ob _:OC _:args _:vbs _:ac) log:onNegativeSurface {
	_:x a :InputPolicyForOutput;
		:input _:input;
		:policy _:policy;
		:output_spec _:output_spec.
	_:output_spec :port _:P.
	_:policy :obligation _:ob.
	_:ob
		:obligation_class _:OC;
		# :argument _:args;
		# :validity_binding _:vb;
		:activation_condition _:ac.

	(_:args0 _:v _:link _:v1 _:context) log:onPositiveSurface {
		_:ob :argument _:args0.
		(
			_:v1
			{
				_:v list:in _:args0.
				_:v :output_to _:link.
				_:link :output_spec _:output_spec;
					:ref _:v1.
			}
			_:args
		) log:collectAllIn (_:context 2).
		(
			()
			{
				:nil list:in _:args.
			}
			()
		) log:collectAllIn (_:context 2).
	}.

	(_:v _:link _:v1 _:context) log:onPositiveSurface {
		(
			_:v1
			{
				_:ob :validity_binding _:v.
				_:v :output_to _:link.
				_:link :output_spec _:output_spec;
					:ref _:v1.
			}
			_:vbs
		) log:collectAllIn (_:context 2).
		(
			()
			{
				:nil list:in _:vbs.
			}
			()
		) log:collectAllIn (_:context 2).
	}.

	() log:onNegativeSurface {
		_:m a :OutputObligation, :Obligation;
			:obligation_class _:OC;
			:argument _:args;
			:validity_binding_list _:vbs;
			:activation_condition _:ac;
			:port _:P.

	}.
}.

(_:ob _:vbs _:vb) log:onNegativeSurface {
	_:ob a :OutputObligation;
		:validity_binding_list _:vbs.

	_:vb list:in _:vbs.

	() log:onNegativeSurface {
		_:ob :validity_binding _:vb.
	}.
}.

#OutputProhibition
(_:x _:input _:policy _:output_spec _:P _:pr _:M _:vbs _:AC) log:onNegativeSurface {
	_:x a :InputPolicyForOutput;
		:input _:input;
		:policy _:policy;
		:output_spec _:output_spec.
	_:output_spec :port _:P.
	_:policy :prohibition _:pr.
	_:pr
		:use_mode _:M;
		# :validity_binding _:VB;
		:activation_condition _:AC.
	
	(_:v _:link _:v1 _:context) log:onPositiveSurface {
		(
			_:v1
			{
				_:ob :validity_binding _:v.
				_:v :output_to _:link.
				_:link :output_spec _:output_spec;
					:ref _:v1.
			}
			_:vbs
		) log:collectAllIn (_:context 2).
		(
			()
			{
				:nil list:in _:vbs.
			}
			()
		) log:collectAllIn (_:context 2).
	}.

	() log:onNegativeSurface {
		_:m a :OutputProhibition, :Prohibition;
			:mode _:M;
			:validity_binding _:vbs;
			:activation_condition _:AC;
			:port _:P.
	}.
}.

(_:pr _:vbs _:vb) log:onNegativeSurface {
	_:pr a :OutputProhibition;
		:validity_binding_list _:vbs.

	_:vb list:in _:vbs.

	() log:onNegativeSurface {
		_:pr :validity_binding _:vb.
	}.
}.

(_:o _:port) log:onNegativeSurface {
	_:o a :OutputSpec;
		:port _:port.
	(_:x _:p) log:onNegativeSurface {
		_:p a :OutputPolicy, :DataPolicy.
		_:x a :OutputPolicyPair;
			:port _:port;
			:policy _:p.
	}.
}.

(_:x _:port _:op _:a _:o _:p _:t) log:onNegativeSurface {
	_:x a :OutputPolicyPair;
		:port _:port;
		:policy _:op.

	_:a a :OutputAttribute;
		:port _:port.
	
	() log:onNegativeSurface {
		_:op :attribute _:a.
	}.
}.

(_:x _:port _:op _:a _:o _:p _:t) log:onNegativeSurface {
	_:x a :OutputPolicyPair;
		:port _:port;
		:policy _:op.

	_:o a :OutputObligation;
		:port _:port.

	() log:onNegativeSurface {
		_:op :obligation _:o.
	}.
}.

(_:x _:port _:op _:a _:o _:p _:t) log:onNegativeSurface {
	_:x a :OutputPolicyPair;
		:port _:port;
		:policy _:op.

	_:p a :OutputProhibition;
		:port _:port.

	() log:onNegativeSurface {
		_:op :prohibition _:p.
	}.
}.

(_:x _:port _:op _:a _:o _:p _:t) log:onNegativeSurface {
	_:x a :OutputPolicyPair;
		:port _:port;
		:policy _:op.

	_:t a :OutputTagging;
		:port _:port.
	
	() log:onNegativeSurface {
		_:op :tagging _:t.
	}.
}.
